#include <inttypes.h>
#include <math.h>
#include <memory.h>
#include <setjmp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void printArray(const char *name, uint8_t *v, size_t len) {
  printf("========%s=========\n", name);
  for (size_t i = 0; i < len; i++) {
    printf("0x%02X,", v[i]);
  }
  printf("\n=================\n");
}
void vm(uint64_t *a, size_t len) {
  size_t eip = 0;
  uint64_t eflags = 0;
  // 共16个寄存器
  while (eip < len) {
    uint64_t instr = a[eip + 2], op1 = a[eip], op2 = a[eip + 1];
    printf("%02x:%02x: ", eip, instr);
    switch ((instr + 128) & 0xFF) {
    case 216:
      printf("xor reg[%d],reg[%d]\n", op1, op2);
      break;
    case 184:
      printf("mov reg[%d] ,%d\n", op1, op2);
      break;
    case 79:
      printf("output\n");
      break;
    case 13:
      printf("input\n");
      break;
    case 31:
      printf("push reg[%d]\n", op1);
      break;
    case 42:
      printf("add reg[%d],%d\n", op1, op2);
      break;
    case 141:
      printf("eflags=reg[%d]<%d\n", op1, op2);
      // eflags=reg[op1]==op2;
      break;
    case 67:
      printf("jnz 0x%x\n", op1);
      break;
    case 181:
      printf("not recognized\n");
      break;
    case 10:
      printf("pop reg[%d]\n", op1);
      break;
    case 148:
      printf("jz 0x%x\n", op1);
      break;
    case 229:
      printf("not recognized\n");
      break;
    case 0:
      printf("mov [reg[%d]],reg[%d]\n", op1, op2);
      break;
    case 122:
      printf("sub reg[%d],%d\n", op1, op2);
      break;
    case 24:
      printf("and reg[%d],reg[%d]\n", op1, op2);
      break;
    case 0x35:
      printf("exit");
      break;
    case 35:
      printf("and reg[%d],%d\n", op1, op2);
      break;
    case 38:
      printf("mov [reg[%d]],%d\n", op1, op2);
      break;
    case 39:
      printf("shl reg[%d],%d\n", op1, op2);
      break;
    case 43:
      printf("sub reg[%d],reg[%d]\n", op1, op2);
      break;
    case 57:
      printf("shl reg[%d],reg[%d]\n", op1, op2);
      break;
    case 78:
      printf("mul reg[%d],reg[%d]\n", op1, op2);
      break;
    case 91:
      printf("shr reg[%d],reg[%d]\n", op1, op2);
      break;
    case 102:
      printf("mov reg[%d],[reg[%d]]\n", op1, op2);
      break;
    case 115:
      printf("or reg[%d],reg[%d]\n", op1, op2);
      break;
    case 171:
      printf("jz 0x%x\n", op1);
      break;
    case 179:
      printf("shr reg[%d],%d\n", op1, op2);
      break;
    case 189:
      printf("mov reg[%d],reg[%d]\n", op1, op2);
      break;
    case 196:
      printf("mul reg[%d],%d\n", op1, op2);
      break;
    case 200:
      printf("add reg[%d],reg[%d]\n", op1, op2);
      break;
    case 235:
      printf("xor reg[%d],%d\n", op1, op2);
      break;
    case 133:
      printf("jmp 0x%x\n", op1);
      break;
    case 37:
      printf("eflags=reg[%d]<reg[%d]\n", op1, op2);
      break;
    }
    eip += 3;
  }
}
int main() {
  // 反汇编脚本
  uint64_t s[1024] = {
      0x0,  0x0,  0x58, 0x1,  0x1,  0x58, 0x2, 0x2,  0x58, 0x3,  0x3,   0x58,
      0x6,  0x6,  0x58, 0x7,  0x7,  0x58, 0x0, 0x69, 0x38, 0x1,  0x6e,  0x38,
      0x2,  0x70, 0x38, 0x3,  0x75, 0x38, 0x6, 0x74, 0x38, 0x7,  0x20,  0x38,
      0x0,  0x0,  0xcf, 0x1,  0x0,  0xcf, 0x2, 0x0,  0xcf, 0x3,  0x0,   0xcf,
      0x6,  0x0,  0xcf, 0x7,  0x0,  0xcf, 0x0, 0x66, 0x38, 0x1,  0x6c,  0x38,
      0x2,  0x61, 0x38, 0x3,  0x67, 0x38, 0x6, 0x3a, 0x38, 0x7,  0x20,  0x38,
      0x0,  0x0,  0xcf, 0x1,  0x0,  0xcf, 0x2, 0x0,  0xcf, 0x3,  0x0,   0xcf,
      0x6,  0x0,  0xcf, 0x7,  0x0,  0xcf, 0x1, 0x1,  0x58, 0x0,  0x0,   0x8d,
      0x0,  0x0,  0x9f, 0x1,  0x1,  0xaa, 0x1, 0x26, 0xd,  0x1f, 0x0,   0xc3,
      0x0,  0x0,  0x35, 0x0,  0x0,  0x8a, 0x0, 0x7d, 0xd,  0x12, 0x0,   0x14,
      0x0,  0x62, 0x38, 0x1,  0x79, 0x38, 0x2, 0x65, 0x38, 0x3,  0x7e,  0x38,
      0x6,  0x7e, 0x38, 0x7,  0x7e, 0x38, 0x0, 0x0,  0xcf, 0x1,  0x0,   0xcf,
      0x2,  0x0,  0xcf, 0x3,  0x0,  0xcf, 0x6, 0x0,  0xcf, 0x7,  0x0,   0xcf,
      0x0,  0xa,  0x38, 0x0,  0x0,  0xcf, 0x0, 0x0,  0x35, 0x8,  0x100, 0x38,
      0x8,  0xe1, 0xd,  0x19, 0x0,  0xc3, 0x0, 0x0,  0x8a, 0x8,  0x0,   0x80,
      0x8,  0x1,  0xfa, 0x13, 0x0,  0x5,  0x0, 0x0,  0x8a, 0x0,  0x7b,  0xd,
      0x3,  0x0,  0x2b, 0x0,  0x0,  0x8a, 0x0, 0x67, 0xd,  0x3,  0x0,   0x2b,
      0x0,  0x0,  0x8a, 0x0,  0x61, 0xd,  0x3, 0x0,  0x2b, 0x0,  0x0,   0x8a,
      0x0,  0x6c, 0xd,  0x3,  0x0,  0x2b, 0x0, 0x0,  0x8a, 0x0,  0x66,  0xd,
      0x3,  0x0,  0x2b, 0x9,  0x9,  0x58, 0xa, 0xe1, 0x38, 0x7,  0x9,   0xe6,
      0x6,  0xa,  0xe6, 0x6,  0xfb, 0x44, 0x6, 0xff, 0xa3, 0x6,  0x7,   0xa5,
      0x3,  0x0,  0x2b, 0x9,  0x1,  0xaa, 0xa, 0x1,  0xaa, 0x9,  0x20,  0xd,
      0x2a, 0x0,  0xc3, 0x0,  0x63, 0x38, 0x1, 0x6f, 0x38, 0x2,  0x72,  0x38,
      0x3,  0x72, 0x38, 0x6,  0x65, 0x38, 0x7, 0x63, 0x38, 0x0,  0x0,   0xcf,
      0x1,  0x0,  0xcf, 0x2,  0x0,  0xcf, 0x3, 0x0,  0xcf, 0x6,  0x0,   0xcf};
  vm(s, sizeof(s) / 8);
  // 解题脚本
  uint8_t cmpData[] = {0xed, 0x06, 0x11, 0x0b, 0xfc, 0xe3, 0xe8, 0x06,
                       0xed, 0x0b, 0xf7, 0xf7, 0x16, 0x06, 0xed, 0x1b,
                       0x0c, 0xfc, 0xe8, 0x0c, 0xf2, 0x16, 0xf7, 0x02,
                       0xf2, 0x11, 0xe3, 0xe3, 0x02, 0x0c, 0xf7, 0xfc};
  char flag[256] = {0};
  for (size_t i = 0; i < 32; i++) {
    for (size_t j = 0x20; j < 0x7f; j++) {
      if (((j * 251) & 0xFF) == cmpData[i]) {
        flag[i] = j;
        printf("%d\n", j);
        break;
      }
    }
  }
  printf("%s\n", flag);
  return 0;
}